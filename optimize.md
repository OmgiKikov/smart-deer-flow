# 架构优化路线图 (更新版)

### **状态总览**

*   ✅ **已完成:** 1. 统一和解耦配置管理
*   🟡 **未开始:** 2. 模块化图组件与工厂模式
*   🟡 **未开始:** 3. Agent 和 Prompt 的标准化管理
*   🟡 **未开始:** 4. 工具的注册与发现机制

---

### **待办优化项 (按重要性排序)**

### 1. (最重要) 模块化图组件与工厂模式

*   **状态:** `未开始`
*   **现状分析:** 您的 `langgraph` 逻辑（可能位于 `src/graph/builder.py` 或 `src/workflow.py`）是整个应用的核心流程。随着未来功能（如我们讨论过的“自我修正”或“多 Agent 辩论”）的加入，这个文件将不可避免地变得庞大、复杂，最终难以维护。
*   **优化建议:** 将复杂的图逻辑分解为可复用的“子图”或“组件”。
    *   **核心策略:**
        1.  **定义子图构建器:** 在 `src/graph/` 下创建一个 `components/` 子目录。在其中为图中每一个逻辑单元创建一个文件，例如 `reflection_loop.py` 或 `research_node.py`。每个文件都应该导出一个函数（例如 `create_reflection_loop()`），该函数接收必要的依赖（如 LLM、Agent）并返回一个配置好的、可独立工作的 `langgraph` 节点或子图。
        2.  **主工作流作为编排者:** 让 `src/graph/builder.py` 的职责转变为“编排者”。它不再包含具体的节点逻辑，而是导入这些组件构建函数，然后像搭乐高一样将它们“缝合”成最终的完整工作流。
    *   **带来的好处:**
        *   **可维护性:** 每个复杂流程（如反思、研究）的逻辑都封装在自己的模块里，修改一个不会影响另一个。
        *   **可复用性:** “反思循环”这个组件可以在项目的多个不同工作流中被复用。
        *   **清晰度:** 主构建流程会变得非常清晰，一眼就能看出整个工作流的宏观结构。

### 2. Agent 和 Prompt 的标准化管理

*   **状态:** `未开始`
*   **现状分析:** Agent 的行为与其 Prompt 紧密耦合。目前，在 `src/agents/agents.py` 中创建 Agent 时，很可能是直接或间接地引用了 `src/prompts/` 目录下的某个具体模板。这使得更换或 A/B 测试 Prompt 非常不便，需要修改代码。
*   **优化建议:** 创建一个 `PromptManager`，让 Agent 的配置决定它使用哪个 Prompt，实现代码与 Prompt 的解耦。
    *   **核心策略:**
        1.  **创建 `PromptManager`:** 这是一个简单的类，在应用启动时加载 `src/prompts/` 目录下的所有 `.md` 文件，并将它们存储在一个字典中，例如 `{"researcher_prompt": "...", "critic_prompt": "..."}`。
        2.  **配置驱动:** 在您的 `src/config/models.py` 中，为 Agent 的配置增加一个 `prompt_name` 字段。
        3.  **动态注入:** 在创建 Agent 实例时，从配置中读取 `prompt_name`，然后用这个名字从 `PromptManager` 中获取对应的 Prompt 文本，并传递给 Agent。
    *   **带来的好处:**
        *   **快速迭代:** 想要测试一个新的 Prompt，只需添加一个新文件并修改配置文件即可，**无需改动任何 Agent 代码**。
        *   **职责分离:** 软件工程师可以专注于 Agent 的逻辑代码，而 Prompt 工程师可以专注于优化 `.md` 文件。

### 3. 工具的注册与发现机制

*   **状态:** `未开始`
*   **现状分析:** 您在 `src/tools/search.py` 中的 `get_web_search_tool` 函数是当前机制的典型例子：它使用一个大的 `if/elif/else` 结构来手动选择和创建工具。每当您想添加一个新的搜索引擎时，都必须修改这个函数。
*   **优化建议:** 实现一个自动化的工具注册表，让工具“即插即用”。
    *   **核心策略:**
        1.  **定义 `BaseTool` 接口:** 在 `src/tools/` 中定义一个所有工具都必须实现的抽象基类或协议（Protocol），它规定了工具必须有 `name`、`description`、`execute` 等属性/方法。
        2.  **创建 `ToolRegistry`:** 这个注册表类在应用启动时，自动扫描 `src/tools/` 目录下的所有文件，找到所有 `BaseTool` 的子类，并将它们的实例注册到一个列表中。
        3.  **动态提供给 Agent:** 当创建 Agent 时，不再手动选择工具，而是将整个 `ToolRegistry` 中注册的所有工具列表都传递给它。Agent 的 Prompt 可以被动态地格式化，以包含所有可用工具的描述。
    *   **带来的好处:**
        *   **即插即用:** 添加一个新工具，只需在 `src/tools/` 目录下创建一个符合接口的新文件即可。Agent 会自动发现并知道如何使用它，无需修改任何中央工厂函数。
        *   **完全解耦:** 工具的管理是完全独立的，极大地降低了维护成本。

---

### **总结**

| 优化领域 (按优先级) | 核心策略 | 关键收益 |
| :--- | :--- | :--- |
| **1. 图(Graph)架构** | 子图组件 + 工厂模式 | 复杂逻辑封装，易于复用和维护；主流程更清晰。 |
| **2. Agent & Prompt** | Prompt 管理器 + 配置驱动 | 快速迭代和测试 Prompt；Agent 与 Prompt 解耦。 |
| **3. 工具(Tools)** | 工具注册表 + 自动发现 | 新工具即插即用，无需手动注册；Agent 自动感知。 |
